"""
# Markten / Recipe / Step

A single step within a recipe.
"""

import asyncio
import inspect
from collections.abc import AsyncGenerator
from typing import Any

from rich.live import Live

from markten.__spinners import SpinnerManager, SpinnerTask
from markten.actions.__action import ActionGenerator, MarktenAction


class RecipeStep:
    def __init__(
        self,
        index: int,
        name: str,
        actions: list[MarktenAction],
    ) -> None:
        self.__index = index
        self.__name = name
        self.__actions = actions

    async def run(
        self,
        parameters: dict[str, Any],
        state: dict[str, Any],
    ) -> AsyncGenerator[dict[str, Any], None]:
        """Run this step of the recipe.

        This receives the parameters from the previous step, and produces a new
        dictionary with parameters for the next step.

        Parameters
        ----------
        parameters : dict[str, Any]
            Parameters to use for this permutation of the recipe.
        state : dict[str, Any]
            Named data produced from previous steps of the recipe. Data from
            this state is included in a new returned dictionary, and updated
            with return values from named actions in this step.

        Yields
        ------
        dict[str, Any]
            Data from this step, to use when running future steps.
        """
        with Live() as live:
            spinners = SpinnerManager(
                f"{self.__index + 1}. {self.__name}", live
            )

            # For each action, turn it into a generator
            generators: list[ActionGenerator] = [
                start_generator(
                    fn, parameters | state, spinners.create_task(str(fn))
                )
                for fn in self.__actions
            ]

            # Now await all yielded values
            tasks: list[asyncio.Task[Any]] = []
            for action in generators:
                tasks.append(asyncio.create_task(anext(action)))

            # Start drawing the spinners
            spinner_task = asyncio.create_task(spinners.spin())
            # Now wait for all tasks to resolve
            results: dict[str, Any] = {}
            task_errors: list[Exception] = []
            for task in tasks:
                try:
                    result = await task
                    if isinstance(result, dict):
                        # Add corresponding values to the results dict
                        for key, value in result.items():
                            results[key] = value
                except Exception as e:
                    task_errors.append(e)

            # Stop spinners
            spinner_task.cancel()

            if len(task_errors):
                raise ExceptionGroup(
                    f"Task failed on step {self.__index + 1}",
                    task_errors,
                )

        # Yield new state to next task
        yield state | results

        # Now do tear-down for all actions in this step
        async with asyncio.TaskGroup() as group:
            [
                group.create_task(run_to_completion(generator))
                for generator in generators
            ]


def start_generator(
    fn: MarktenAction,
    context: dict[str, Any],
    task: SpinnerTask,
) -> ActionGenerator:
    """Execute an action generator function, passing any desired parameters as
    kwargs.

    Parameters
    ----------
    fn : MarktenAction
        Function to call to produce generator
    parameters : Mapping[str, Any]
        Recipe parameters
    context : Mapping[str, Any]
        Context generated by previous actions
    task : SpinnerTask
        Spinner task, used to update status

    Returns
    -------
    ActionGenerator
        Return of that function, given its required parameters.
    """
    namespace = context | { "task": task }

    args = inspect.getfullargspec(fn)
    # Check if function uses kwargs
    kwargs_used = args[2] is not None
    if kwargs_used:
        # If so, pass the full namespace
        return fn(**namespace)
    else:
        # Otherwise, only pass the args it requests
        named_args = args[0]
        param_subset = {
            name: value
            for name, value in namespace.items()
            if name in named_args
        }
        return fn(**param_subset)


async def run_to_completion(action: ActionGenerator):
    """Run the given action generator until it is completed"""
    async for _ in action:
        ...
